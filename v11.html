<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain Rot - Pulsating Particles</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; background: #000; overflow: hidden; }
        #shader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
        .logo { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; height: 50vh; pointer-events: none; }
        .logo svg { height: 100%; width: auto; }
        #svgCanvas { display: none; }
    </style>
</head>
<body>
    <canvas id="shader"></canvas>
    <canvas id="svgCanvas"></canvas>
    <div class="logo" id="logoContainer">
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 703.91 933.59">
  <defs>
    <style>
      .cls-1 { fill: #f9f8f6; }
      .cls-2 { fill: #231f20; }
      .cls-3 { fill: #fff; }
      .cls-4 { fill: #ed2890; }
    </style>
  </defs>
  <path class="cls-4" d="M472.72,566.76l12.8.04c-3.33,37.07-34.8,70.35-61.29,93.11-.77.66.61,5.35-.05,6.01-12.46,12.52-29.87,22.91-44.74,32.44.15,19.62-.15,39.56-.28,59.2-3.39,4.51-12.41,13.14-16.72,17.43-5.56-.11-11.29.02-16.86.08-5.39-5.11-10.93-10.8-16.23-16.06-.44-20.33-.66-40.65-.63-60.98-14.7-9.25-32.85-20.39-46.01-31.45l2.32-6.28c-31.86-24.67-54.64-51.75-63.6-91.51l.84-1.14c3.4-.85,8.8-.48,12.47-.39.65,3.89,1.37,7.67,2.29,11.51,11.45,48,65.21,80.95,105.65,104.73.65,11.61-1.92,63,2.01,69.06l1.32.21c2.56-3.76,1.63-26.24,1.75-32.51,3.9-.14,8.38,0,12.33.05.6,7.44-.33,27.22,1.96,32.34l1.16.19c.44-.6.87-1.18,1.3-1.77,1.6-18.61.87-49.89.87-67.43,37.41-22.2,79.94-49.45,99.82-89.19,4.02-8.04,5.98-18.8,7.51-27.67Z"/>
  <path class="cls-4" d="M351.93,312.87c5.57.35,65.95,49.84,75.44,57.32.57,21.43.21,46.92-.46,68.33,3.18,2.98,14.12,10.09,18.32,13.23,16.38,12.23,26.78,22.43,38.1,39.1,4.76-2.23,12.1-6.72,17.22-4.24l.31,1.47c-2.85,5.52-7.66,6.82-13.36,9.42,2.88,7.24,5.83,14.44,8.85,21.62,9.18-.5,29.19-4.98,33.99-3.61l.35.99c-4.94,6.14-24.68,9.22-32.45,10.44.6,5.05,2.6,11.16-.05,15.03-2.01,1.29-3.94.84-6.46.7-7.38-52.91-34.69-73.57-77.31-100.65-1.01-18.21,1.27-51-.97-67.05-.84-6.07-50.76-42.68-58.09-46.95-8.72-2.81-48.65,34.12-57.96,40.46-7.89,5.37-5.7,23.4-5.67,32.76.15,13.67.13,27.34-.07,41.02-31.11,20.28-54.8,35.11-69.36,71.88-3.61,9.11-4.97,20.64-8.24,28.72l-3.12.73c-5.99-1.68-3.13-10.35-2.43-15.51-6.98-1.45-30.21-6.1-33.02-11.63l.71-1.68c4.41-2.87,11.41,2.38,16.46,3.15,5.85.89,12.06.92,17.97,1.14l8.38-20.66c-6.04-3.12-10.12-4.57-14.13-10.19l1.09-1.82c5.01-1.01,12.76,2.94,17.32,4.9,16.3-25.71,32.12-35.03,55.52-52.34l-.35-68.39c14.69-12.59,30.8-24.36,45.67-36.86,8.56-7.2,18.24-15.07,27.79-20.81Z"/>
  <path class="cls-4" d="M349.45,339.45c3.13-.16,3.82-.35,6.75.47,2.31,3.3,1.67,32.78,1.75,38.83,2.88,3.66,4.89,6.45,7.45,10.34.48,10.73-.22,21.56.39,32.79,5.49,4.9,18.24,11.81,24.92,16.04,27.44,17.35,58.63,33.77,77.77,60.52,5.97,8.34,18.24,33.76,16.35,43.77-1.97,1.66-8.27,1.74-8.61.23-13.29-60.43-73.03-84.42-121.05-115.68-.38-.22-1.99-.7-2.24-.54-44.13,29.44-102.94,51.11-119.2,106.28-1.09,3.69-1.96,9.52-5.27,11.48-3.08,0-3.51.5-5.85-.94-1.46-3.43-.5-6.41.23-9.84,11.07-52.26,61.55-75.35,103.04-101.4,4.57-2.87,9.37-5.42,13.63-8.86l.69-.56c1.05-10.07.45-22.82.83-33.48,2.6-4.34,4.47-6.4,7.82-10.28.32-12.8-.41-26.48.61-39.15Z"/>
  <path class="cls-2" d="M347.73,531.51c15.53-3.3,30.83,6.42,34.15,21.69s-6.6,30.3-22.13,33.53c-15.49,3.22-30.71-6.49-34.02-21.72-3.31-15.22,6.54-30.21,22.01-33.5Z"/>
  <path class="cls-4" d="M347.57,535.25c8.75-2.23,18.05.38,24.29,6.82,6.24,6.44,8.45,15.69,5.76,24.19-2.69,8.49-9.84,14.89-18.68,16.72-13.26,2.74-26.31-5.43-29.4-18.4-3.09-12.97,4.92-25.99,18.03-29.33Z"/>
  <path class="cls-2" d="M349.49,543.66c8.35-2.56,17.21,2.01,19.83,10.21,2.61,8.2-2.03,16.93-10.37,19.51-8.35,2.58-17.24-1.99-19.85-10.21-2.61-8.21,2.04-16.95,10.4-19.51Z"/>
  <path class="cls-4" d="M346.15,144.34c13.37-3.33,26.95,4.67,30.27,17.84,3.31,13.17-4.89,26.48-18.31,29.67-13.31,3.16-26.71-4.84-30-17.91-3.29-13.07,4.77-26.29,18.04-29.6Z"/>
  <path class="cls-4" d="M363.25,129c3.83.31,9.54,3.68,12.62,5.96,11.13,8.22,16.75,22.46,15.59,35.92-.94,11.04-6.38,21.25-15.05,28.32-5.98,4.85-11.21,6.86-18.37,9.48-1.29,8.51-1.55,23.99-.35,32.56,14.5,12.69,18.61,22.67,1.07,35.77-1.1,6.43-.95,11.34-.96,17.8,1.72,1.31,3.94,2.9,5.55,4.27l-.28,12.65c-3.34-1.68-7.22-3.79-10.7-4.99l-9.05,4.75c-.42-4.26-.84-8.08-.88-12.35l5.51-4.37c0-5.75.07-11.34-.29-17.09-16.25-12.9-17.59-22.01-.28-35.77,1.83-7.81,2.61-23.71.02-31.36-.81-2.4-15.61-8.82-18.77-11.47-25.67-21.57-18.83-58.08,11.92-70.2l.16,9.78c-17.5,10.97-27.58,26.93-14.82,46.32,4.55,6.93,11.78,11.73,20.02,13.28,8.53,1.65,17.52.1,24.74-4.76,6.83-4.62,11.52-11.72,13.03-19.73,1.43-8.07-.41-16.37-5.13-23.12-3.58-5-9.76-10.38-15.87-11.98-.18-2.14.37-7.27.57-9.67Z"/>
  <path class="cls-2" d="M349.59,253.79c2.46-1.08,5.33-.75,7.47.86,2.14,1.61,3.23,4.23,2.83,6.86-.4,2.62-2.22,4.82-4.75,5.74-3.74,1.36-7.9-.45-9.4-4.08-1.5-3.63.2-7.78,3.85-9.37Z"/>
  <path class="cls-4" d="M347.58,60.05c-3.81-2.31-6.12-3.35-8.78-6.97-5.91-8.02-3.89-17.63,5.26-22.63,4.14-2.3,9.06-2.83,13.62-1.48,9.66,2.91,11.55,12.25,9.18,20.94-1.4,5.12-5.97,7.56-10.37,9.9-.51,17.97-.23,40.16,1.29,58.23.05.7,2.38,7.49,2.79,8.91,1.3,2,.42,1.35,2.69,2.05-.2,2.4-.74,7.54-.57,9.67-1.9.78-14.58.4-17.23.22-4.35-.3-1.68-7.58-.77-10.45.18-4.97,2.86-9.17,2.9-12.75.22-17.88,1-37.97,0-55.65Z"/>
  <path class="cls-2" d="M349.68,37.26c3.77-1.26,7.86.71,9.15,4.42,1.3,3.7-.71,7.73-4.47,9.01-3.77,1.28-7.89-.69-9.18-4.4-1.3-3.71.72-7.76,4.5-9.02Z"/>
</svg>
    </div>
    <script>
        const canvas = document.getElementById('shader');
        const gl = canvas.getContext('webgl');
        const svgCanvas = document.getElementById('svgCanvas');
        const svgCtx = svgCanvas.getContext('2d');
        let logoTexture = null;
        let logoRect = { x: 0, y: 0, w: 1, h: 1 };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            updateLogoTexture();
        }

        function updateLogoTexture() {
            const logo = document.querySelector('.logo svg');
            const rect = logo.getBoundingClientRect();
            logoRect.x = rect.left / window.innerWidth;
            logoRect.y = 1.0 - (rect.bottom / window.innerHeight);
            logoRect.w = rect.width / window.innerWidth;
            logoRect.h = rect.height / window.innerHeight;
            svgCanvas.width = 512; svgCanvas.height = 512;
            const img = new Image();
            const svgData = new XMLSerializer().serializeToString(logo);
            const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(svgBlob);
            img.onload = function() {
                svgCtx.clearRect(0, 0, 512, 512);
                svgCtx.drawImage(img, 0, 0, 512, 512);
                URL.revokeObjectURL(url);
                if (!logoTexture) logoTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, logoTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, svgCanvas);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            };
            img.src = url;
        }

        resize(); window.onresize = resize;
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, 'attribute vec2 pos;void main(){gl_Position=vec4(pos,0,1);}');
        gl.compileShader(vs);
        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            uniform sampler2D logo;
            uniform vec4 logoRect;

            float getLogo(vec2 uv) {
                vec2 logoUV = (uv - logoRect.xy) / logoRect.zw;
                logoUV.y = 1.0 - logoUV.y;
                if (logoUV.x >= 0.0 && logoUV.x <= 1.0 && logoUV.y >= 0.0 && logoUV.y <= 1.0) {
                    return texture2D(logo, logoUV).a;
                }
                return 0.0;
            }

            // Soft glow sampling around logo for bloom effect
            float getLogoGlow(vec2 uv, float radius) {
                float glow = 0.0;
                float samples = 0.0;
                glow += getLogo(uv + vec2(radius, 0.0)); samples += 1.0;
                glow += getLogo(uv + vec2(-radius, 0.0)); samples += 1.0;
                glow += getLogo(uv + vec2(0.0, radius)); samples += 1.0;
                glow += getLogo(uv + vec2(0.0, -radius)); samples += 1.0;
                glow += getLogo(uv + vec2(radius*0.707, radius*0.707)); samples += 1.0;
                glow += getLogo(uv + vec2(-radius*0.707, radius*0.707)); samples += 1.0;
                glow += getLogo(uv + vec2(radius*0.707, -radius*0.707)); samples += 1.0;
                glow += getLogo(uv + vec2(-radius*0.707, -radius*0.707)); samples += 1.0;
                float r2 = radius * 2.0;
                glow += getLogo(uv + vec2(r2, 0.0)) * 0.5; samples += 0.5;
                glow += getLogo(uv + vec2(-r2, 0.0)) * 0.5; samples += 0.5;
                glow += getLogo(uv + vec2(0.0, r2)) * 0.5; samples += 0.5;
                glow += getLogo(uv + vec2(0.0, -r2)) * 0.5; samples += 0.5;
                return glow / samples;
            }

            // Get dilated logo mask for hull detection
            float getLogoHull(vec2 uv) {
                float hull = 0.0;
                float r1 = 0.025;
                float r2 = 0.05;
                float r3 = 0.08;

                hull += getLogo(uv);
                hull += getLogo(uv + vec2(r1, 0.0));
                hull += getLogo(uv + vec2(-r1, 0.0));
                hull += getLogo(uv + vec2(0.0, r1));
                hull += getLogo(uv + vec2(0.0, -r1));
                hull += getLogo(uv + vec2(r1*0.707, r1*0.707));
                hull += getLogo(uv + vec2(-r1*0.707, r1*0.707));
                hull += getLogo(uv + vec2(r1*0.707, -r1*0.707));
                hull += getLogo(uv + vec2(-r1*0.707, -r1*0.707));

                hull += getLogo(uv + vec2(r2, 0.0)) * 0.6;
                hull += getLogo(uv + vec2(-r2, 0.0)) * 0.6;
                hull += getLogo(uv + vec2(0.0, r2)) * 0.6;
                hull += getLogo(uv + vec2(0.0, -r2)) * 0.6;

                hull += getLogo(uv + vec2(r3, 0.0)) * 0.3;
                hull += getLogo(uv + vec2(-r3, 0.0)) * 0.3;
                hull += getLogo(uv + vec2(0.0, r3)) * 0.3;
                hull += getLogo(uv + vec2(0.0, -r3)) * 0.3;

                return clamp(hull, 0.0, 1.0);
            }

// Pulsating particles with physics simulation
// Particles are affected by force waves emanating from the logo hull

vec3 palette(float d) {
    return vec3(0.9, 0.2, 0.6) + vec3(0.1, 0.3, 0.4) * cos(6.28 * (d + vec3(0.0, 0.1, 0.2)));
}

float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
vec2 hash2(vec2 p) { return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453); }

// Calculate distance to logo hull boundary
float hullDistance(vec2 uv) {
    float hull = getLogoHull(uv);
    // Find gradient direction toward hull
    float dx = getLogoHull(uv + vec2(0.01, 0.0)) - getLogoHull(uv - vec2(0.01, 0.0));
    float dy = getLogoHull(uv + vec2(0.0, 0.01)) - getLogoHull(uv - vec2(0.0, 0.01));

    // Return approximate distance (negative inside, positive outside)
    return hull > 0.1 ? -hull : length(vec2(dx, dy)) * 0.5;
}

// Calculate force from pulsating hull
vec2 hullForce(vec2 uv, float time) {
    float hull = getLogoHull(uv);

    // Gradient of hull (points toward hull)
    float dx = getLogoHull(uv + vec2(0.005, 0.0)) - getLogoHull(uv - vec2(0.005, 0.0));
    float dy = getLogoHull(uv + vec2(0.0, 0.005)) - getLogoHull(uv - vec2(0.0, 0.005));
    vec2 toHull = normalize(vec2(dx, dy) + 0.0001);

    // Pulsating wave emanating from hull
    float pulseFreq = 2.0; // pulses per second
    float waveSpeed = 0.3; // how fast waves travel outward
    float dist = 1.0 - hull; // distance from hull

    // Multiple overlapping waves for organic feel
    float wave1 = sin(dist * 30.0 - time * pulseFreq * 6.28) * 0.5 + 0.5;
    float wave2 = sin(dist * 20.0 - time * pulseFreq * 6.28 * 0.7 + 1.0) * 0.5 + 0.5;
    float wave3 = sin(dist * 40.0 - time * pulseFreq * 6.28 * 1.3 + 2.0) * 0.5 + 0.5;

    float wave = (wave1 + wave2 * 0.5 + wave3 * 0.3) / 1.8;
    wave = pow(wave, 2.0); // sharpen peaks

    // Force pushes outward from hull during pulse
    float forceMag = wave * (1.0 - dist * 2.0); // stronger near hull
    forceMag = max(0.0, forceMag);

    // Outward direction (negative of toHull)
    return -toHull * forceMag * 0.02;
}

void main() {
    vec2 uv = gl_FragCoord.xy / r;
    vec2 p = (gl_FragCoord.xy - 0.5 * r) / r.y;
    float inLogo = getLogo(uv);
    float time = t;

    vec3 col = vec3(0.02, 0.0, 0.03);

    // Simulate ~50 particles with physics
    float particles = 0.0;
    float trails = 0.0;

    // Each "particle" has initial position from hash, velocity affected by hull force
    // We simulate forward in time to find current position

    // Particle 1-10 (unrolled for iOS)
    vec2 initPos; vec2 vel; vec2 pos; float life; float dist; float id;
    vec2 force; float particleGlow;

    // Simulate multiple particles
    id = 1.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.8;
    life = fract(time * 0.15 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.3;
    pos = initPos;
    // Apply force over time (simplified - just sample current force)
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 20.0;
    pos = mod(pos + 1.0, 2.0) - 1.0; // wrap
    dist = length(p - pos);
    particleGlow = 0.008 / (dist + 0.008);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 3.0 + id));

    id = 2.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.8;
    life = fract(time * 0.18 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.25;
    pos = initPos;
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 18.0;
    pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos);
    particleGlow = 0.007 / (dist + 0.007);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 2.5 + id));

    id = 3.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.6;
    life = fract(time * 0.12 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.35;
    pos = initPos;
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 22.0;
    pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos);
    particleGlow = 0.009 / (dist + 0.009);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 3.5 + id));

    id = 4.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.7;
    life = fract(time * 0.2 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.28;
    pos = initPos;
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 15.0;
    pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos);
    particleGlow = 0.006 / (dist + 0.006);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 2.8 + id));

    id = 5.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.9;
    life = fract(time * 0.16 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.32;
    pos = initPos;
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 20.0;
    pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos);
    particleGlow = 0.008 / (dist + 0.008);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 3.2 + id));

    id = 6.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.5;
    life = fract(time * 0.22 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.26;
    pos = initPos;
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 17.0;
    pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos);
    particleGlow = 0.007 / (dist + 0.007);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 2.6 + id));

    id = 7.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.8;
    life = fract(time * 0.14 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.3;
    pos = initPos;
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 19.0;
    pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos);
    particleGlow = 0.009 / (dist + 0.009);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 3.3 + id));

    id = 8.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.6;
    life = fract(time * 0.19 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.27;
    pos = initPos;
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 21.0;
    pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos);
    particleGlow = 0.006 / (dist + 0.006);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 2.9 + id));

    id = 9.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.7;
    life = fract(time * 0.17 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.33;
    pos = initPos;
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 16.0;
    pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos);
    particleGlow = 0.008 / (dist + 0.008);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 3.1 + id));

    id = 10.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.9;
    life = fract(time * 0.13 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.29;
    pos = initPos;
    force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 23.0;
    pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos);
    particleGlow = 0.007 / (dist + 0.007);
    particles += particleGlow * (0.5 + 0.5 * sin(time * 2.7 + id));

    // More particles (11-20)
    id = 11.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.8;
    life = fract(time * 0.21 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.31;
    pos = initPos; force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 18.0; pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos); particles += 0.007 / (dist + 0.007) * (0.5 + 0.5 * sin(time * 3.4 + id));

    id = 12.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.6;
    life = fract(time * 0.11 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.34;
    pos = initPos; force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 20.0; pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos); particles += 0.008 / (dist + 0.008) * (0.5 + 0.5 * sin(time * 2.4 + id));

    id = 13.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.7;
    life = fract(time * 0.23 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.28;
    pos = initPos; force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 17.0; pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos); particles += 0.006 / (dist + 0.006) * (0.5 + 0.5 * sin(time * 3.6 + id));

    id = 14.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.5;
    life = fract(time * 0.16 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.36;
    pos = initPos; force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 22.0; pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos); particles += 0.009 / (dist + 0.009) * (0.5 + 0.5 * sin(time * 2.2 + id));

    id = 15.0; initPos = (hash2(vec2(id, 0.0)) - 0.5) * 1.9;
    life = fract(time * 0.19 + hash(vec2(id, 1.0)));
    vel = (hash2(vec2(id, 2.0)) - 0.5) * 0.25;
    pos = initPos; force = hullForce((pos + 1.0) * 0.5, time);
    pos += vel * life + force * life * 19.0; pos = mod(pos + 1.0, 2.0) - 1.0;
    dist = length(p - pos); particles += 0.007 / (dist + 0.007) * (0.5 + 0.5 * sin(time * 3.0 + id));

    // Color the particles
    col += palette(particles * 0.3 + time * 0.1) * particles;

    // Visualize the pulsating waves from hull
    float hull = getLogoHull(uv);
    float waveDist = 1.0 - hull;
    float pulseWave = sin(waveDist * 30.0 - time * 12.56) * 0.5 + 0.5;
    pulseWave *= smoothstep(0.8, 0.0, waveDist); // fade with distance
    pulseWave *= smoothstep(0.0, 0.2, hull); // only visible near hull
    col += vec3(1.0, 0.3, 0.7) * pulseWave * 0.3;

    // Darken background behind logo hull
    float darkenAmount = smoothstep(0.0, 0.3, hull) * 0.75;
    col = mix(col, col * 0.1, darkenAmount);

    // Soft logo glow
    float logoGlow = getLogoGlow(uv, 0.015);
    float softLogo = smoothstep(0.0, 0.8, inLogo);
    col += palette(0.5) * logoGlow * 0.4;
    col += vec3(1.0, 0.5, 0.85) * softLogo * 0.2 * (0.6 + 0.4 * sin(t * 2.0));
    col = mix(col, col * 1.2 + vec3(0.15, 0.03, 0.12), logoGlow * 0.35);

    // Vignette
    col *= 1.0 - smoothstep(0.2, 1.2, length(p));

    // Bloom
    col += col * col * 0.3;

    gl_FragColor = vec4(col, 1.0);
}
        `);
        gl.compileShader(fs);
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(fs));
        const prog = gl.createProgram();
        gl.attachShader(prog, vs); gl.attachShader(prog, fs);
        gl.linkProgram(prog); gl.useProgram(prog);
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
        const posAttr = gl.getAttribLocation(prog, 'pos');
        gl.enableVertexAttribArray(posAttr);
        gl.vertexAttribPointer(posAttr, 2, gl.FLOAT, false, 0, 0);
        const rLoc = gl.getUniformLocation(prog, 'r');
        const tLoc = gl.getUniformLocation(prog, 't');
        const logoLoc = gl.getUniformLocation(prog, 'logo');
        const logoRectLoc = gl.getUniformLocation(prog, 'logoRect');
        function render(time) {
            gl.uniform2f(rLoc, canvas.width, canvas.height);
            gl.uniform1f(tLoc, time * 0.001);
            gl.uniform4f(logoRectLoc, logoRect.x, logoRect.y, logoRect.w, logoRect.h);
            if (logoTexture) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, logoTexture);
                gl.uniform1i(logoLoc, 0);
            }
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }
        setTimeout(() => { updateLogoTexture(); render(0); }, 100);
    </script>
</body>
</html>
