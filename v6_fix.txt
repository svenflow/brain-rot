vec2 hash2(vec2 p) {
    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
    return fract(sin(p) * 43758.5453);
}

void main() {
    vec2 uv = gl_FragCoord.xy / r;
    float inLogo = getLogo(uv);
    vec2 pt = uv * 8.0;
    vec2 n = floor(pt); vec2 f = fract(pt);
    float minDist = 8.0;
    
    // Unrolled 3x3 neighbor loop for iOS
    vec2 point;
    float d;
    
    point = hash2(n + vec2(-1,-1)); point = 0.5 + 0.5*sin(t*0.5 + 6.28*point); d = length(f - vec2(-1,-1) - point); minDist = min(minDist, d);
    point = hash2(n + vec2(0,-1)); point = 0.5 + 0.5*sin(t*0.5 + 6.28*point); d = length(f - vec2(0,-1) - point); minDist = min(minDist, d);
    point = hash2(n + vec2(1,-1)); point = 0.5 + 0.5*sin(t*0.5 + 6.28*point); d = length(f - vec2(1,-1) - point); minDist = min(minDist, d);
    point = hash2(n + vec2(-1,0)); point = 0.5 + 0.5*sin(t*0.5 + 6.28*point); d = length(f - vec2(-1,0) - point); minDist = min(minDist, d);
    point = hash2(n + vec2(0,0)); point = 0.5 + 0.5*sin(t*0.5 + 6.28*point); d = length(f - vec2(0,0) - point); minDist = min(minDist, d);
    point = hash2(n + vec2(1,0)); point = 0.5 + 0.5*sin(t*0.5 + 6.28*point); d = length(f - vec2(1,0) - point); minDist = min(minDist, d);
    point = hash2(n + vec2(-1,1)); point = 0.5 + 0.5*sin(t*0.5 + 6.28*point); d = length(f - vec2(-1,1) - point); minDist = min(minDist, d);
    point = hash2(n + vec2(0,1)); point = 0.5 + 0.5*sin(t*0.5 + 6.28*point); d = length(f - vec2(0,1) - point); minDist = min(minDist, d);
    point = hash2(n + vec2(1,1)); point = 0.5 + 0.5*sin(t*0.5 + 6.28*point); d = length(f - vec2(1,1) - point); minDist = min(minDist, d);
    
    float v = minDist + inLogo * 0.2 * sin(t * 2.0);
    vec3 col = vec3(0.6, 0.12, 0.4) * v * 0.7;
    col *= 1.0 - smoothstep(0.25, 0.85, length(uv - 0.5));
    gl_FragColor = vec4(col, 1.0);
}
